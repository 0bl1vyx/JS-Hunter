#!/bin/bash
# --- Colors & Styles ---
# Hacker minimalist theme: Matrix-inspired greens, subtle cyans, clean contrasts.
HACKER_GREEN=$(tput setaf 2) # Main text and success
CYAN=$(tput setaf 6) # Highlights and info
ORANGE=$(tput setaf 3) # Warnings
RED=$(tput setaf 1) # Errors
WHITE=$(tput setaf 7) # Neutral text
DIM=$(tput dim) # Subtle dim for details
BOLD=$(tput bold)
NC=$(tput sgr0) # No Color
# --- UI Functions ---
banner() {
    echo -e "${HACKER_GREEN}${BOLD}"
    echo "██╗███████╗ █████╗ ███╗ ██╗ ██╗ ██║██╗ ██╗"
    echo "██║██╔════╝██╔══██╗████╗ ██║ ██║ ██║╚██╗ ██╔╝"
    echo "██║███████╗███████║██╔██╗ ██║ ██║ ██║ ╚████╔╝"
    echo "██║╚════██║██╔══██║██║╚██╗██║ ╚██╗ ██╔╝ ╚██╔╝"
    echo "██║███████║██║ ██║██║ ╚████║ ╚████╔╝ ██║"
    echo "╚═╝╚══════╝╚═╝ ╚═╝╚═╝ ╚═══╝ ╚═══╝ ╚═╝"
    echo "      by Crypt Specter"
    echo -e "${NC}"
}
header() {
    echo -e "\n${CYAN}${BOLD}┌─ ${1} ─┐${NC}"
}
stage() {
    echo -e "${HACKER_GREEN}${BOLD}┃ ${WHITE}${1}${NC}"
}
substage() {
    echo -e "${CYAN}┗━▶ ${1}${NC}"
}
tool_result() {
    echo -e "    ├── ${1}${NC}"
}
detail() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${DIM}   • ${1}${NC}"
    fi
}
help_menu() {
    header "Command Guide"
    echo -e "${CYAN}Usage:${NC} $0 [options]\n"
    echo -e "${ORANGE}Essential:${NC}"
    echo -e " -dl <file> Domain list input (txt)"
    echo -e "${ORANGE}Optional:${NC}"
    echo -e " -o <file> JS URLs output"
    echo -e " -s <file> Secrets output"
    echo -e " -e <file> Endpoints output"
    echo -e " -lv <1-4> Discovery level (default: 4)"
    echo -e " -c <num> Concurrency level (default: 4)"
    echo -e " -v Verbose output (extra details)"
    echo -e " -h, --help This guide\n"
    echo -e "${HACKER_GREEN}Example:${NC} $0 -dl domains.txt -o js.txt -s secrets.txt -e endpoints.txt -lv 2 -c 8 -v"
    exit 0
}
error() {
    echo -e "\n${RED}${BOLD}✖ Error: ${1}${NC}"
    exit 1
}
warn() {
    echo -e "${ORANGE}${BOLD}⚠ Warning: ${1}${NC}"
}
info() {
    echo -e "${CYAN}ℹ ${1}${NC}"
}
confirm_overwrite() {
    local file="$1"
    if [[ -f "$file" ]]; then
        read -p "${ORANGE}⁉ Overwrite $file? (y/n): ${NC}" confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            error "Aborted."
        fi
    fi
}
# Trap for cleanup
trap 'rm -f "$DOMAINS" "$URLS" "$ALL_JS_URLS" "$LIVE_JS" "${results[@]}" 2>/dev/null' EXIT
# --- Argument Parsing ---
DOMAIN_LIST_INPUT=""
JS_URLS_FILE=""
SECRETS_FILE=""
ENDPOINTS_FILE=""
LEVEL=4
CONCURRENCY=4
VERBOSE=false
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -dl|-o|-s|-e|-lv|-c)
            if [[ $# -lt 2 || "$2" == -* ]]; then
                error "Missing value for $key"
            fi
            value="$2"
            shift 2
            case $key in
                -dl) DOMAIN_LIST_INPUT="$value" ;;
                -o) JS_URLS_FILE="$value" ;;
                -s) SECRETS_FILE="$value" ;;
                -e) ENDPOINTS_FILE="$value" ;;
                -lv) LEVEL="$value" ;;
                -c) CONCURRENCY="$value" ;;
            esac
            ;;
        -v) VERBOSE=true; shift ;;
        -h|--help) help_menu ;;
        *) error "Invalid option: $1" ;;
    esac
done
# --- Validation ---
[[ -z "$DOMAIN_LIST_INPUT" ]] && error "Domain list required (-dl <file>)"
[[ ! -f "$DOMAIN_LIST_INPUT" ]] && error "File '$DOMAIN_LIST_INPUT' not found"
[[ ! "$LEVEL" =~ ^[1-4]$ ]] && error "Level must be 1-4"
[[ ! "$CONCURRENCY" =~ ^[1-9][0-9]*$ ]] && error "Concurrency must be a positive integer"
# --- Dynamic Dependency Check ---
declare -A tools=(
    [1]="subjs"
    [2]="katana"
    [3]="waybackurls"
    [4]="gau"
)
dependencies=("httpx")
for i in $(seq 1 "$LEVEL"); do
    dependencies+=("${tools[$i]}")
done
[[ -n "$SECRETS_FILE" || -n "$ENDPOINTS_FILE" ]] && dependencies+=("nuclei")
dependencies=($(echo "${dependencies[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' '))
for dep in "${dependencies[@]}"; do
    command -v "$dep" &> /dev/null || error "Missing: $dep"
done
detail "Dependencies checked: ${dependencies[*]}"
# --- Overwrite Confirmation ---
[[ -n "$JS_URLS_FILE" ]] && confirm_overwrite "$JS_URLS_FILE"
[[ -n "$SECRETS_FILE" ]] && confirm_overwrite "$SECRETS_FILE"
[[ -n "$ENDPOINTS_FILE" ]] && confirm_overwrite "$ENDPOINTS_FILE"
# --- Main Execution ---
clear
banner
start_time=$(date +%s)
detail "Processing input: $DOMAIN_LIST_INPUT"
DOMAINS=$(mktemp)
sed -E 's|^https?://||' "$DOMAIN_LIST_INPUT" | sort -u > "$DOMAINS"
detail "Domains prepared: $(wc -l < "$DOMAINS") unique"
URLS=$(mktemp)
awk '{print "https://" $0}' "$DOMAINS" > "$URLS"
detail "URLs ready for scanning"
UA="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36"
detail "User-Agent set: $UA"
# --- Discovery Phase ---
stage "Phase 1: Discovering JavaScript URLs (Level: $LEVEL)"
declare -A pids
declare -A results
for i in $(seq 1 $LEVEL); do
    tool=${tools[$i]}
    results[$tool]=$(mktemp)
    detail "Launching $tool"
    detail "Temp file: ${results[$tool]}"
    case $tool in
        "subjs")
            subjs -i "$URLS" -ua "$UA" -c "$CONCURRENCY" > "${results[$tool]}" &
            ;;
        "katana")
            cat "$URLS" | xargs -P "$CONCURRENCY" -I {} sh -c "katana -u {} -jc -silent -H 'User-Agent: $UA' | grep -Ei '\.js([?#].*)?\$' >> '${results[$tool]}'" &
            ;;
        "waybackurls")
            cat "$DOMAINS" | xargs -P "$CONCURRENCY" -I {} sh -c "waybackurls {} | grep -Ei '\.js([?#].*)?\$' >> '${results[$tool]}'" &
            ;;
        "gau")
            cat "$DOMAINS" | xargs -P "$CONCURRENCY" -I {} sh -c "gau {} | grep -Ei '\.js([?#].*)?\$' >> '${results[$tool]}'" &
            ;;
    esac
    pids[$tool]=$!
    detail "PID: ${pids[$tool]}"
done
# Real-time monitoring
domains_count=$(wc -l < "$DOMAINS")
while true; do
    all_done=true
    for pid in "${pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            all_done=false
        fi
    done
    if $all_done; then break; fi
    clear
    banner
    stage "Phase 1: Discovering JavaScript URLs (Level: $LEVEL)"
    substage "Discovery in Progress..."
    raw_found=0
    for res in "${results[@]}"; do
        ((raw_found += $(wc -l < "$res" 2>/dev/null || echo 0)))
    done
    echo -e "    ├── Raw JS Mentions Found: $raw_found 🚀"
    echo -e "    ├── Domains Scanned: $domains_count 📡"
    echo -e "    └── Elapsed Time: $(( $(date +%s) - start_time ))s ⏱"
    sleep 1
done
# Check exit codes
for tool in "${!pids[@]}"; do
    wait "${pids[$tool]}"
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        warn "$tool failed (code $exit_code)"
    else
        detail "$tool complete: $(wc -l < "${results[$tool]}") URLs"
    fi
done
clear
banner
stage "Phase 1: Discovering JavaScript URLs (Level: $LEVEL)"
substage "Discovery Complete."
for tool in "${!results[@]}"; do
    tool_result "$tool : $(wc -l < "${results[$tool]}") URLs found"
done
# --- Consolidation Phase ---
stage "Phase 2: Consolidating and Filtering URLs"
ALL_JS_URLS=$(mktemp)
detail "Merging results into: $ALL_JS_URLS"
cat "${results[@]}" | sort -u > "$ALL_JS_URLS"
total_js=$(wc -l < "$ALL_JS_URLS" | tr -d ' ')
substage "Found $total_js unique JS URLs."
[[ $total_js -eq 0 ]] && error "No JS URLs found"
if [[ -n "$JS_URLS_FILE" ]]; then
    cp "$ALL_JS_URLS" "$JS_URLS_FILE"
    detail "Exported to $JS_URLS_FILE"
fi
# --- Live Filtering ---
stage "Phase 3: Live URL Filtering"
LIVE_JS=$(mktemp)
httpx -l "$ALL_JS_URLS" -silent -mc 200 -o "$LIVE_JS" &
httpx_pid=$!
# Real-time for filtering
while kill -0 "$httpx_pid" 2>/dev/null; do
    clear
    banner
    stage "Phase 3: Live URL Filtering"
    substage "Filtering in Progress..."
    temp_live=$(wc -l < "$LIVE_JS" 2>/dev/null || echo 0)
    echo -e "    ├── Live JS URLs Found: $temp_live ✅"
    echo -e "    └── Elapsed Time: $(( $(date +%s) - start_time ))s ⏱"
    sleep 1
done
wait "$httpx_pid"
live_count=$(wc -l < "$LIVE_JS" | tr -d ' ')
substage "Found $live_count live JS URLs (200 OK)."
[[ $live_count -eq 0 ]] && warn "No live JS URLs found"
SCAN_TARGETS="$LIVE_JS"
# --- Analysis Phase ---
SECRETS_FOUND=0
ENDPOINTS_FOUND=0
secrets_pid=""
endpoints_pid=""
if [[ -n "$SECRETS_FILE" || -n "$ENDPOINTS_FILE" ]]; then
    stage "Phase 4: Analysis Phase"
fi
if [[ -n "$SECRETS_FILE" ]]; then
    detail "Scanning for secrets"
    touch "$SECRETS_FILE"
    nuclei -l "$SCAN_TARGETS" -t exposures/tokens/ -o "$SECRETS_FILE" -silent &
    secrets_pid=$!
    detail "Nuclei PID (secrets): $secrets_pid"
fi
if [[ -n "$ENDPOINTS_FILE" ]]; then
    detail "Scanning for endpoints"
    touch "$ENDPOINTS_FILE"
    nuclei -l "$SCAN_TARGETS" -t javascript/ -o "$ENDPOINTS_FILE" -silent &
    endpoints_pid=$!
    detail "Nuclei PID (endpoints): $endpoints_pid"
fi
if [[ -n "$secrets_pid" || -n "$endpoints_pid" ]]; then
    # Real-time monitoring for analysis
    while true; do
        all_done=true
        [[ -n "$secrets_pid" ]] && kill -0 "$secrets_pid" 2>/dev/null && all_done=false
        [[ -n "$endpoints_pid" ]] && kill -0 "$endpoints_pid" 2>/dev/null && all_done=false
        if $all_done; then break; fi
        clear
        banner
        stage "Phase 4: Analysis Phase"
        substage "Analysis in Progress..."
        temp_secrets=$(wc -l < "$SECRETS_FILE" 2>/dev/null || echo 0)
        temp_endpoints=$(wc -l < "$ENDPOINTS_FILE" 2>/dev/null || echo 0)
        echo -e "    ├── Secrets Found: $temp_secrets ⚠️"
        echo -e "    ├── Endpoints Found: $temp_endpoints 🔗"
        echo -e "    └── Elapsed Time: $(( $(date +%s) - start_time ))s ⏱"
        sleep 1
    done
fi
# Wait and check exit codes
if [[ -n "$secrets_pid" ]]; then
    wait "$secrets_pid"
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        warn "Secrets scan failed (code $exit_code)"
    fi
    SECRETS_FOUND=$(wc -l < "$SECRETS_FILE" | tr -d ' ')
    detail "Secrets found: $SECRETS_FOUND"
    if [[ $SECRETS_FOUND -eq 0 ]]; then
        rm "$SECRETS_FILE"
        SECRETS_FILE=""
        detail "Empty secrets file removed"
    fi
fi
if [[ -n "$endpoints_pid" ]]; then
    wait "$endpoints_pid"
    exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        warn "Endpoints scan failed (code $exit_code)"
    fi
    ENDPOINTS_FOUND=$(wc -l < "$ENDPOINTS_FILE" | tr -d ' ')
    detail "Endpoints found: $ENDPOINTS_FOUND"
    if [[ $ENDPOINTS_FOUND -eq 0 ]]; then
        rm "$ENDPOINTS_FILE"
        ENDPOINTS_FILE=""
        detail "Empty endpoints file removed"
    fi
fi
# --- Summary ---
clear
banner
end_time=$(date +%s)
total_time=$((end_time - start_time))
stage "Phase 5: Results Summary"
substage "Recon complete. 🎉"
echo -e "    ├── Total JS URLs Found: $total_js 🚀"
echo -e "    ├── Live URLs (200 OK): $live_count ✅"
[[ -n "$JS_URLS_FILE" ]] && echo -e "    ├── JS File: $JS_URLS_FILE 📄"
if [[ -n "$SECRETS_FILE" ]]; then
    echo -e "    ├── Secrets: $SECRETS_FOUND ⚠️ ($SECRETS_FILE)"
else
    echo -e "    ├── Secrets: 0 (None)"
fi
if [[ -n "$ENDPOINTS_FILE" ]]; then
    echo -e "    ├── Endpoints: $ENDPOINTS_FOUND 🔗 ($ENDPOINTS_FILE)"
else
    echo -e "    ├── Endpoints: 0 (None)"
fi
echo -e "    └── Time Taken: ${total_time}s ⏱"
